import { test, expect, describe, beforeAll, afterAll } from 'bun:test';
import * as fs from 'fs';
import * as path from 'path';
import { Project } from 'ts-morph';
import * as aesc from '../aesc';

// Mock the callOllama function before all tests
const callOllamaMock = async (declaration: any, originalImportPath: string): Promise<string> => {
    const interfaceName = declaration.getName()!;
    if (interfaceName === 'DB') {
        return `
// Generated by AutoGen (mock)
import { DB, User } from '${originalImportPath}';
export class DBImpl extends DB {
  users = new Map<string, User>();
  save(user: User): void { this.users.set(user.name, user); }
  find(name: string): User | undefined { return this.users.get(name); }
}`;
    }
    if (interfaceName === 'UserService') {
        return `
// Generated by AutoGen (mock)
import { User, UserService } from '${originalImportPath}';
export class UserServiceImpl extends UserService {
    create(user: User): void { this.db?.save(user); }
    findByName(name: string): User | undefined { return this.db?.find(name); }
}`;
    }
    return `// Fallback mock for ${interfaceName}`;
};

// We need to spy on the original module to mock one of its exports
const aescModule = {
    ...aesc,
    callOllama: callOllamaMock,
};

describe('E2E test for handleGenerate', () => {
    const projectBasePath = path.resolve(__dirname, '..');
    const originalOutputDir = 'src/generated';
    const testOutputDir = 'src/generated_e2e_test';

    beforeAll(() => {
        const outputFullPath = path.join(projectBasePath, testOutputDir);
        if (fs.existsSync(outputFullPath)) {
            fs.rmSync(outputFullPath, { recursive: true, force: true });
        }
    });

    afterAll(() => {
        const outputFullPath = path.join(projectBasePath, testOutputDir);
        if (fs.existsSync(outputFullPath)) {
            fs.rmSync(outputFullPath, { recursive: true, force: true });
        }
    });

    test('should generate a container that fails to inject dependencies', async () => {
        // Temporarily modify aesc.ts to use a different output directory for the test
        const aescPath = path.join(projectBasePath, 'aesc.ts');
        const originalAescContent = fs.readFileSync(aescPath, 'utf-8');
        const modifiedAescContent = originalAescContent.replace(`const OUTPUT_DIR = '${originalOutputDir}'`, `const OUTPUT_DIR = '${testOutputDir}'`);
        fs.writeFileSync(aescPath, modifiedAescContent);

        try {
            // We need to create a new Project instance that will pick up the modified aesc.ts
            const project = new Project({ tsConfigFilePath: path.join(projectBasePath, 'tsconfig.json'), skipAddingFilesFromTsConfig: true });
            project.addSourceFilesAtPaths('src/**/*.ts');

            // Manually create a mock of handleGenerate that uses our mocked callOllama
            const handleGenerateWithMock = async (force: boolean, files: string[]) => {
                // This is a simplified reimplementation of the start of handleGenerate
                const outputDir = path.join(projectBasePath, testOutputDir);
                fs.mkdirSync(outputDir, { recursive: true });
                const generatedServices: aesc.GeneratedService[] = [];

                const sourceFile = project.getSourceFileOrThrow('user.ts');
                const cls = sourceFile.getClassOrThrow('UserController');
                const prop = cls.getPropertyOrThrow('userService');
                const propType = prop.getType();
                const targetType = propType.isUnion() ? propType.getUnionTypes().find(t => !t.isUndefined()) : propType;
                const decl = targetType!.getSymbol()!.getDeclarations()[0] as any;
                const interfaceName = decl.getName()!;
                const implName = `${interfaceName}Impl`;
                const implFileName = `${interfaceName.toLowerCase()}.service.impl.ts`;
                const implFilePath = path.join(outputDir, implFileName);

                const generatedCode = await callOllamaMock(decl, '../user');
                fs.writeFileSync(implFilePath, generatedCode);

                const tempProject = new Project({ useInMemoryFileSystem: true });
                project.getSourceFiles().forEach(sf => {
                    tempProject.createSourceFile(sf.getFilePath(), sf.getFullText());
                });
                const tempSourceFile = tempProject.createSourceFile(implFilePath, generatedCode);
                const implClass = tempSourceFile.getClass(implName)!;

                const { constructorDeps, propertyDeps } = aesc.getDependencies(implClass);
                generatedServices.push({
                    interfaceName,
                    implName,
                    implFilePath: `./${implFileName}`,
                    constructorDependencies: constructorDeps,
                    propertyDependencies: propertyDeps,
                });

                // Also generate DB service
                const dbDecl = project.getSourceFileOrThrow('user.ts').getClassOrThrow('DB');
                const dbImplCode = await callOllamaMock(dbDecl, '../user');
                fs.writeFileSync(path.join(outputDir, 'db.service.impl.ts'), dbImplCode);
                generatedServices.push({
                    interfaceName: 'DB',
                    implName: 'DBImpl',
                    implFilePath: './db.service.impl.ts',
                    constructorDependencies: [],
                    propertyDependencies: [],
                });

                await aesc.generateContainer(outputDir, generatedServices);
            };

            await handleGenerateWithMock(true, ['user.ts']);

            const containerPath = path.join(projectBasePath, testOutputDir, 'container.ts');
            const containerContent = fs.readFileSync(containerPath, 'utf-8');

            const expectedInjectionCode = `instance.db = this.get('DB');`;
            expect(containerContent).toContain(expectedInjectionCode);

        } finally {
            // Restore aesc.ts to its original state
            fs.writeFileSync(aescPath, originalAescContent);
        }
    });
});
