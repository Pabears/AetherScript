import * as fs from 'fs';
import * as path from 'path';
import type { GeneratedService } from './file-analysis';

export async function generateContainer(outputDir: string, services: GeneratedService[]) {
    const imports = services.map(s => `import { ${s.implName} } from '${s.implFilePath.replace(/\\/g, '/').replace(/\.ts$/, '')}';`).join('\n');

    const typeMappings = services.map(s => `    '${s.interfaceName}': ${s.implName};`).join('\n');

    // Helper function to extract interface name from type string
    const extractInterfaceName = (typeStr: string): string => {
        // Handle types like "import(\"/path/to/file\").InterfaceName" or "InterfaceName"
        if (typeStr.includes('import(')) {
            // Extract from import("...").InterfaceName
            const match = typeStr.match(/\)\.([A-Za-z_][A-Za-z0-9_]*)$/);
            return match?.[1] || typeStr;
        }
        // Handle simple interface names
        return typeStr;
    };

    const factoryMappings = services.map(s => {
        let factoryCode = `        '${s.interfaceName}': () => {\n`;
        factoryCode += `            const instance = new ${s.implName}();\n`;
        s.propertyDependencies.forEach(dep => {
            const depInterfaceName = extractInterfaceName(dep.type);
            factoryCode += `            instance.${dep.name} = this.get('${depInterfaceName}');\n`;
        });
        factoryCode += `            return instance;\n`;
        factoryCode += `        }`;
        return factoryCode;
    }).join(',\n');

    const containerCode = `// Generated by AutoGen at ${new Date().toISOString()}
${imports}

interface ServiceMap {
${typeMappings}
}

class Container {
    private instances: Map<keyof ServiceMap, any> = new Map();

    private factories: { [K in keyof ServiceMap]: () => ServiceMap[K] };

    constructor() {
        this.factories = {
${factoryMappings}
        };
    }

    public get<K extends keyof ServiceMap>(identifier: K): ServiceMap[K] {
        if (!this.instances.has(identifier)) {
            const factory = this.factories[identifier];
            if (!factory) {
                throw new Error('Service not found for identifier: ' + identifier);
            }
            const instance = factory();
            this.instances.set(identifier, instance);
        }
        return this.instances.get(identifier) as ServiceMap[K];
    }
}

export const container = new Container();
`;

    const outputPath = path.join(outputDir, 'container.ts');
    fs.writeFileSync(outputPath, containerCode);
}

export function saveGeneratedFile(filePath: string, content: string): void {
    fs.writeFileSync(filePath, content);
    console.log(`  -> Wrote to ${filePath}`);
}

export function ensureOutputDirectory(outputDir: string, force: boolean): void {
    if (force) {
        console.log(`--force specified, cleaning directory: ${outputDir}`);
        fs.rmSync(outputDir, { recursive: true, force: true });
    }
    fs.mkdirSync(outputDir, { recursive: true });
}

// --- Lock File Management ---
const LOCK_FILE = 'aesc.lock';

export function getLockData(): string[] {
    if (fs.existsSync(LOCK_FILE)) {
        try {
            return JSON.parse(fs.readFileSync(LOCK_FILE, 'utf-8')) || [];
        } catch { return []; }
    }
    return [];
}

export function saveLockData(data: string[]) {
    fs.writeFileSync(LOCK_FILE, JSON.stringify(Array.from(new Set(data)), null, 2));
}

export function handleLockUnlock(paths: string[], action: 'lock' | 'unlock') {
    const actionFunc = action === 'lock' ? lockFile : unlockFile;
    const actionDirFunc = action === 'lock' ? lockDirectory : unlockDirectory;
    for (const p of paths) {
        try {
            if (fs.statSync(p).isDirectory()) {
                actionDirFunc(p);
            } else {
                actionFunc(p);
            }
        } catch (error: any) {
            console.error(`Error accessing path ${p}:`, error.message);
        }
    }
}

function lockFile(filePath: string) {
    const lockedFiles = getLockData();
    const absolutePath = path.resolve(filePath);
    if (!lockedFiles.includes(absolutePath)) {
        lockedFiles.push(absolutePath);
        saveLockData(lockedFiles);
        console.log(`  -> Locked ${filePath}`);
    }
}

function unlockFile(filePath: string) {
    let lockedFiles = getLockData();
    const absolutePath = path.resolve(filePath);
    const initialCount = lockedFiles.length;
    lockedFiles = lockedFiles.filter(p => p !== absolutePath);
    if (lockedFiles.length < initialCount) {
        saveLockData(lockedFiles);
        console.log(`  -> Unlocked ${filePath}`);
    }
}

function lockDirectory(dirPath: string) {
    const { Project } = require("ts-morph");
    const project = new Project();
    project.addSourceFilesAtPaths(`${dirPath}/**/*.ts`);
    const lockedFiles = getLockData();
    let changed = false;
    for (const sourceFile of project.getSourceFiles()) {
        const filePath = path.resolve(sourceFile.getFilePath());
        if (!lockedFiles.includes(filePath)) {
            lockedFiles.push(filePath);
            changed = true;
        }
    }
    if (changed) saveLockData(lockedFiles);
    console.log(`  -> Locked all files in ${dirPath}`);
}

function unlockDirectory(dirPath: string) {
    let lockedFiles = getLockData();
    const absoluteDirPath = path.resolve(dirPath);
    const initialCount = lockedFiles.length;
    lockedFiles = lockedFiles.filter(p => !p.startsWith(absoluteDirPath));
    if (lockedFiles.length < initialCount) {
        saveLockData(lockedFiles);
        console.log(`  -> Unlocked all files in ${dirPath}`);
    }
}
