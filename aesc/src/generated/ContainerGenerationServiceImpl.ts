import { ContainerGenerationService } from '../services/ContainerGenerationService';
import type { GeneratedService } from '../services/types';
import * as path from 'path';

/**
 * Concrete implementation of the ContainerGenerationService.
 * This class is responsible for generating the dependency injection
 * container code for the target project.
 */
export class ContainerGenerationServiceImpl implements ContainerGenerationService {
    public async generateContainerCode(services: GeneratedService[]): Promise<string> {
        const normalizeServiceId = (interfaceName: string): string => interfaceName;

        const extractInterfaceName = (typeStr: string): string => {
            if (typeStr.includes('import(')) {
                const match = typeStr.match(/\)\.([A-Za-z_][A-Za-z0-9_]*)$/);
                return normalizeServiceId(match?.[1] || typeStr);
            }
            return normalizeServiceId(typeStr);
        };

        const uniqueServices = services.reduce((acc, service) => {
            const normalizedName = normalizeServiceId(service.interfaceName);
            if (!acc.some(s => normalizeServiceId(s.interfaceName) === normalizedName)) {
                acc.push(service);
            }
            return acc;
        }, [] as GeneratedService[]);

        const imports = uniqueServices.map(s => {
            const normalizedPath = s.implFilePath.replace(/\\/g, '/').replace(/\.ts$/, '');
            return `import { ${s.implName} } from '${normalizedPath}';`;
        }).join('\n');

        const typeMappings = uniqueServices.map(s => {
            return `    '${normalizeServiceId(s.interfaceName)}': ${s.implName};`;
        }).join('\n');

        const factoryMappings = uniqueServices.map(s => {
            const serviceId = normalizeServiceId(s.interfaceName);
            let factoryCode = `        '${serviceId}': () => {\n`;
            factoryCode += `            const instance = new ${s.implName}();\n`;
            (s.propertyDependencies || []).forEach(dep => {
                factoryCode += `            instance.${dep.name} = this.get('${extractInterfaceName(dep.type)}');\n`;
            });
            factoryCode += `            return instance;\n`;
            factoryCode += `        }`;
            return factoryCode;
        }).join(',\n');

        const timestamp = new Date().toISOString();

        return `// Generated by aesc at ${timestamp}
${imports}

interface ServiceMap {
${typeMappings}
}

class Container {
    private instances: Map<keyof ServiceMap, any> = new Map();
    private factories: { [K in keyof ServiceMap]: () => ServiceMap[K] };

    constructor() {
        this.factories = {
${factoryMappings}
        };
    }

    public get<K extends keyof ServiceMap>(identifier: K): ServiceMap[K] {
        if (!this.instances.has(identifier)) {
            const factory = this.factories[identifier];
            if (!factory) {
                throw new Error('Service not found for identifier: ' + identifier);
            }
            const instance = factory();
            this.instances.set(identifier, instance);
        }
        return this.instances.get(identifier) as ServiceMap[K];
    }
}

export const container = new Container();
`;
    }
}
