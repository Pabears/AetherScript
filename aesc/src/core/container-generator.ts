import * as fs from 'fs';
import * as path from 'path';
import type { GeneratedService } from '../file-analysis';

export async function generateContainer(outputDir: string, services: GeneratedService[]) {
    // Extract the actual class name from interface name
    // Use the original interface/class name as service identifier (e.g., "DB", "ProductService", "CacheService")
    const normalizeServiceId = (interfaceName: string): string => {
        // Simply return the interface name as-is since it's already the correct class name
        // Examples: "DB" -> "DB", "ProductService" -> "ProductService", "CacheService" -> "CacheService"
        return interfaceName;
    };

    // Helper function to extract interface name from type string and normalize it
    const extractInterfaceName = (typeStr: string): string => {
        // Handle types like "import(\"/path/to/file\").InterfaceName" or "InterfaceName"
        if (typeStr.includes('import(')) {
            // Extract from import("...").InterfaceName
            const match = typeStr.match(/\)\.([A-Za-z_][A-Za-z0-9_]*)$/);
            const rawName = match?.[1] || typeStr;
            return normalizeServiceId(rawName);
        }
        // Handle simple interface names
        return normalizeServiceId(typeStr);
    };

    // Deduplicate services by normalized interface name to prevent duplicate definitions
    const uniqueServices = services.reduce((acc, service) => {
        const normalizedName = normalizeServiceId(service.interfaceName);
        const existingIndex = acc.findIndex(s => normalizeServiceId(s.interfaceName) === normalizedName);
        if (existingIndex >= 0) {
            // Replace with newer service definition (in case of updates)
            acc[existingIndex] = service;
        } else {
            acc.push(service);
        }
        return acc;
    }, [] as GeneratedService[]);
    
    console.log(`[Container] Generating container with ${uniqueServices.length} unique services (deduplicated from ${services.length} total)`);
    
    // Generate imports using normalized service names
    const imports = uniqueServices.map(s => {
        const normalizedPath = s.implFilePath.replace(/\\/g, '/').replace(/\.ts$/, '');
        return `import { ${s.implName} } from '${normalizedPath}';`;
    }).join('\n');

    // Generate type mappings using normalized service identifiers
    const typeMappings = uniqueServices.map(s => {
        const serviceId = normalizeServiceId(s.interfaceName);
        return `    '${serviceId}': ${s.implName};`;
    }).join('\n');

    const factoryMappings = uniqueServices.map(s => {
        const serviceId = normalizeServiceId(s.interfaceName);
        console.log(`[Container] Processing service: ${serviceId}`);
        console.log(`[Container] Property dependencies:`, s.propertyDependencies);
        
        let factoryCode = `        '${serviceId}': () => {\n`;
        factoryCode += `            const instance = new ${s.implName}();\n`;
        
        s.propertyDependencies.forEach(dep => {
            const depInterfaceName = extractInterfaceName(dep.type);
            console.log(`[Container] Adding dependency injection: instance.${dep.name} = this.get('${depInterfaceName}')`);
            factoryCode += `            instance.${dep.name} = this.get('${depInterfaceName}');\n`;
        });
        
        factoryCode += `            return instance;\n`;
        factoryCode += `        }`;
        
        console.log(`[Container] Generated factory code for ${serviceId}:`);
        console.log(factoryCode);
        
        return factoryCode;
    }).join(',\n');

    // Generate container code using template configuration
    const generateContainerTemplate = () => {
        const timestamp = new Date().toISOString();
        const errorMessage = 'Service not found for identifier: ';
        
        return {
            header: `// Generated by AutoGen at ${timestamp}`,
            imports,
            serviceMapInterface: {
                name: 'ServiceMap',
                mappings: typeMappings
            },
            containerClass: {
                name: 'Container',
                instancesField: 'private instances: Map<keyof ServiceMap, any> = new Map();',
                factoriesField: 'private factories: { [K in keyof ServiceMap]: () => ServiceMap[K] };',
                constructor: {
                    factoryMappings
                },
                getMethod: {
                    name: 'get',
                    signature: 'public get<K extends keyof ServiceMap>(identifier: K): ServiceMap[K]',
                    errorMessage
                }
            },
            exportStatement: 'export const container = new Container();'
        };
    };

    const template = generateContainerTemplate();
    
    const containerCode = `${template.header}
${template.imports}

interface ${template.serviceMapInterface.name} {
${template.serviceMapInterface.mappings}
}

class ${template.containerClass.name} {
    ${template.containerClass.instancesField}

    ${template.containerClass.factoriesField}

    constructor() {
        this.factories = {
${template.containerClass.constructor.factoryMappings}
        };
    }

    ${template.containerClass.getMethod.signature} {
        if (!this.instances.has(identifier)) {
            const factory = this.factories[identifier];
            if (!factory) {
                throw new Error('${template.containerClass.getMethod.errorMessage}' + identifier);
            }
            const instance = factory();
            this.instances.set(identifier, instance);
        }
        return this.instances.get(identifier) as ServiceMap[K];
    }
}

${template.exportStatement}
`;

    const outputPath = path.join(outputDir, 'container.ts');
    fs.writeFileSync(outputPath, containerCode);
}
