# AetherScript: A Contract-Driven Paradigm for Reliable Human-AI Code Collaboration

**Abstract**

As Large Language Models (LLMs) become increasingly integrated into software development, AI programming tools are evolving from code completion to automated code generation. However, prevailing methods often lack predictability and control, making it difficult for developers to fully trust AI-generated code. This paper introduces AetherScript, a novel AI programming paradigm centered on the core principle of "Design by Contract," which explicitly separates human developer intent from AI implementation. We detail AetherScript's workflow and technical architecture, explaining how it leverages static code analysis, context-rich prompt engineering, automated dependency injection, and an innovative "file lock" mechanism to foster trustworthy human-AI collaboration. The paper concludes by summarizing AetherScript's contributions to the field of AI-assisted programming and outlines future directions for its development.

**1. Introduction**

From GitHub Copilot to various integrated development environment (IDE) assistants, Large Language Models (LLMs) are profoundly reshaping software development. While these tools significantly boost productivity, they also introduce new challenges:
*   **Unpredictability ("Hallucinations")**: AI can generate code that is functionally incorrect, logically flawed, or even contains security vulnerabilities.
*   **Loss of Control**: Large blocks of "magically" generated code may not align with the style and quality of the existing codebase, increasing the burden of code review and maintenance.
*   **Lack of Transparency**: The AI's decision-making process is a "black box," making it difficult for developers to understand its generation logic and, consequently, to build trust.

To address these issues, we argue for a new collaborative paradigm that combines traditional software engineering principles with the powerful capabilities of AI. Our project, AetherScript, is the embodiment of this philosophy. Its core principle is the **complete separation of human intent from AI implementation**. In this model, the AI is no longer a free-form creator but an implementer bound by a strict "contract," thereby placing the development process firmly back under human control.

**2. The AetherScript Workflow: A Contract-Driven Approach**

AetherScript introduces a structured workflow centered around the concept of a "contract."

1.  **Defining the Contract**: The developer uses a TypeScript `interface` or `abstract class` to define a clear contract. This contract precisely describes the functionality, method signatures, and properties a module must implement, essentially capturing the developer's "intent."

2.  **Declaring AI Implementation**: In a class that depends on this contract, the developer uses the `@AutoGen` decorator to mark a property. This decorator serves as an explicit signal to the AetherScript toolchain: "The implementation for this dependency will be generated by AI."

3.  **Automated Orchestration**: The developer runs the `aesc gen` command. The AetherScript toolchain then automatically performs the following steps:
    *   **Parsing**: It scans the entire project to find all dependencies marked with `@AutoGen`.
    *   **Generation**: For each contract to be implemented, it constructs a context-rich prompt and invokes an LLM (such as CodeLlama hosted via Ollama) to generate the concrete implementation code.
    *   **Injection**: It saves the generated code into a dedicated `src/generated` directory and seamlessly integrates it into the application via an automatically generated dependency injection (DI) container.

This model confines the AI's creativity within a well-defined sandbox, ensuring the final output strictly adheres to human-predefined specifications.

**3. The AetherScript Orchestration Engine: A Look Under the Hood**

The power of AetherScript lies in its orchestration engine, which transforms a developer's declarative intent into fully implemented, production-ready code. This process can be broken down into several automated steps, triggered by the `aesc gen` command. Let's walk through a concrete example from the `demo` project.

**Step 1: The Human Contract**

A developer first defines an `abstract class` as a contract. This includes method signatures and, crucially, can include natural language comments to guide the AI.

```typescript
// file: src/service/user-service.ts
export abstract class UserService {
    @AutoGen
    public db?: DB; // Another contract to be fulfilled by AI

    // 1. check: 3 < name.length < 15 and 0 <= age <= 120
    // 2. db.save(user)
    public abstract create(user: User): void;

    // find user by name from db
    public abstract findByName(name: string): User | undefined;
}
```

**Step 2: Declaring Intent**

In another part of the application, such as a controller, the developer declares a dependency on this contract using the `@AutoGen` decorator.

```typescript
// file: src/controller/user-controller.ts
export class UserController {
    @AutoGen
    public userService?: UserService;

    // ... methods that use this.userService
}
```

**Step 3: Static Analysis**

Upon running `aesc gen`, the engine uses `ts-morph` to parse the entire codebase's Abstract Syntax Tree (AST). It identifies `UserController.userService` as a target and resolves its type to the `UserService` contract.

**Step 4: Context-Rich Prompt Generation**

This is the most critical step. The engine gathers all necessary context and constructs a highly specific prompt for the LLM. It recursively finds all dependent types (`User`, `DB`) and includes their definitions. The final prompt looks like this:

**Anatomy of an AetherScript Prompt**

```
You are a TypeScript code generation engine.
Your task is to implement the following abstract class.
You must follow these rules strictly:
1. The implementation class name must be 'UserServiceImpl'.
2. The implementation class MUST 'extend' the original abstract class 'UserService'.
3. You MUST implement all abstract methods directly. Do NOT create private helper methods for the core logic.
4. You MUST NOT redeclare any properties already present in the base class. Access them with 'this'.
5. Your response MUST be only the raw TypeScript code. No explanations, no markdown.

Here are the dependent type definitions:
\`\`\`typescript
// From: src/entity/user.ts
export class User {
    constructor(public name: string, public age: number) {

    }
}

// From: src/service/db-service.ts
export abstract class DB {
    protected users = new Map<string, User>();

    // save user to users
    public abstract save(user: User): void;
    // find user from users
    public abstract find(name: string): User | undefined;
}
\`\`\`

Here is the abstract class you must implement:
\`\`\`typescript
export abstract class UserService {
    @AutoGen
    public db?: DB;
    // 1. check: 3 < name.length < 15 and 0 <= age <= 120
    // 2. db.save(user)
    public abstract create(user: User): void;

    // find user by name from db
    public abstract findByName(name: string): User | undefined;
}
\`\`\`
```

**Step 5: LLM Invocation and Post-Processing**

The engine sends this prompt to the LLM via the Ollama API. The raw response is then parsed to extract *only* the `export class UserServiceImpl { ... }` block, discarding any conversational boilerplate. This ensures the output is clean, executable code.

**Step 6: Code Generation and Dependency Injection**

The cleaned code is written to a new file: `src/generated/userservice.service.impl.ts`. The engine then updates (or creates) a DI container, registering `UserServiceImpl` as the concrete implementation for the `UserService` contract. This container will also handle injecting the `DBImpl` dependency into the `UserServiceImpl` instance at runtime.

This highly structured, automated process ensures that the generated code is not a "black box" but a predictable, reliable, and well-integrated component of the application architecture.

**4. In-Depth Architectural Analysis**

AetherScript's reliability is not accidental but is built upon a sophisticated technical architecture.

*   **Static Code Analysis**: AetherScript utilizes the `ts-morph` library to parse TypeScript source code. It traverses the Abstract Syntax Tree (AST) to accurately identify `@AutoGen` decorators, resolve their type definitions (the contracts), and recursively find all related dependent types. This approach is far more robust and precise than simple text processing with regular expressions, forming the foundation for reliable code generation.

*   **Context-Rich Prompt Engineering**: AetherScript's success is largely due to its meticulous prompt engineering. Before calling the LLM, it provides not only the interface definition to be implemented but also uses static analysis to extract and include all dependent types (DTOs, Enums, etc.) as context. Furthermore, the prompt contains extremely strict instructions, such as naming conventions for the implementation class, the requirement to extend the base class, and a prohibition on creating private helper methods. This "high-context, high-constraint" prompt strategy significantly reduces the LLM's room for "creative freedom," thereby ensuring the determinism and compliance of the output.

*   **Automated Dependency Injection**: AetherScript does more than just generate isolated class files. After all implementations are generated, it automatically creates a dependency injection container. This container is responsible for instantiating all generated services and their dependencies and injecting them where needed. This follows the Inversion of Control (IoC) principle of modern software engineering, promoting loose coupling and enabling the generated code to be integrated cleanly and maintainably.

*   **Human-in-the-Loop & Lock File Mechanism**: AetherScript fully acknowledges that AI is not perfect and that human oversight and intervention are crucial. To this end, it introduces an innovative `aesc.lock` file mechanism. When a developer is unsatisfied with an AI-generated file and modifies it manually, the file's path is recorded in `aesc.lock`. During the next run, AetherScript skips all locked files, thus protecting human modifications from being overwritten. This simple mechanism greatly enhances the workflow's practicality, allowing developers to fine-tune and optimize on top of the AI's foundation, enabling true human-AI collaboration.

**5. Contributions to AI-Assisted Development**

AetherScript's exploration offers several key contributions to the field of AI programming:

*   **Enhanced Trust and Predictability**: By constraining the AI's scope to human-defined contracts, AetherScript transforms the uncertainty of AI into a predictable and verifiable engineering process.
*   **Strengthened Human Control**: Developers remain the architects and rule-makers. Mechanisms like the file lock ensure that humans have the final say over the code.
*   **Promotion of Software Engineering Best Practices**: AetherScript encourages developers to write clear interfaces and automatically applies design patterns like dependency injection, helping to improve the overall quality and maintainability of the project.
*   **A New Collaborative Paradigm**: It demonstrates a deeper mode of human-AI collaboration that goes beyond "code completion," pointing to a new direction for the future of AI programming tools.

**6. Empirical Validation**

To substantiate the claim that AetherScript's contract-driven approach improves reliability, we conducted a series of stress tests. The methodology involved a test script that repeatedly ran the entire code generation and execution cycle for the `demo` project, measuring the success rate of different models in producing valid, executable code that passed the application's runtime checks.

**Test Results**

The table below compares the performance of two models within the AetherScript framework. The baseline `codellama:7b` model was compared against the more advanced `qwen2.5-coder:32b`.

| Model                   | Iterations | Success Rate |
| ----------------------- | ---------- | ------------ |
| `codellama:7b`          | 100        | 57.0%        |
| `qwen2.5-coder:32b`     | 100        | **100%**     |

While the superior model performs better, the more significant finding is how AetherScript's structured prompting elevates the performance of *both* models compared to their unconstrained, standard benchmark scores. The `pass@1` metric represents the probability that a model generates correct code in a single attempt on general coding tasks.

| Model                   | Standard Benchmark (`pass@1`) | AetherScript Success Rate |
| ----------------------- | ----------------------------- | ------------------------- |
| `codellama:7b`          | 28.7%¹                        | **57.0% (+28.3%)**        |
| `qwen2.5-coder:32b`     | 60.9%²                        | **100% (+39.1%)**         |

*¹ HumanEval `pass@1` score. ² Code Editing `pass@1` score.*

**Analysis**

The data clearly indicates that AetherScript provides a significant reliability uplift. By transforming a general code generation task into a specific, contract-fulfillment task, the framework dramatically increases the probability of success. The rich context and strict constraints provided in the prompt act as powerful guardrails, guiding the LLM toward a correct implementation. This demonstrates that the AetherScript paradigm doesn't just automate coding; it makes AI-driven code generation a more reliable and predictable engineering discipline.

**7. Future Directions**

While AetherScript is currently a prototype, its potential is immense. Future development could focus on several areas:

*   **Support for More Languages and Ecosystems**: Extending the AetherScript philosophy to other major languages like Python (with type hints), Java, and Go.
*   **Bidirectional Synchronization**: Not only generating implementations from interfaces but also updating or validating interface definitions when a developer modifies an implementation, creating a tighter, two-way binding.
*   **Automated Test Generation**: Concurrently with generating implementations, using AI to automatically write unit tests for the generated code, further ensuring code quality.
*   **Smarter Refactoring Support**: When a widely-used interface changes, the AI could automatically update all dependent implementation code, greatly simplifying refactoring in large-scale projects.

*   **Synergy with Test-Driven Development (TDD)**: The combination of AetherScript and TDD can create a powerful "Test-Driven Generation" (TDG) workflow. A developer would first write a failing test and define the associated interface (the contract). Then, they would run AetherScript to generate an implementation that makes the test pass. The future vision is to feed the test case itself to the LLM as part of the prompt, instructing it to "implement this interface *so that this test passes*." This would provide the AI with a concrete, executable specification of the required behavior, dramatically improving the quality and reliability of the generated code and accelerating the Red-Green-Refactor cycle.

**8. Conclusion**

AetherScript is not intended to replace developers but to create a more efficient and reliable human-AI collaborative environment. By incorporating the software engineering principle of "Design by Contract," it successfully places "reins" on the powerful capabilities of AI, turning it into a trustworthy and controllable tool in the hands of developers. We believe that this structure- and contract-based paradigm is a critical step in advancing AI programming from an "art" to an "engineering" discipline.
