import { Project, InterfaceDeclaration, ts } from "ts-morph";
import * as fs from 'fs';
import * as path from 'path';

type GeneratedService = {
    interfaceName: string;
    implName: string;
    implFilePath: string;
};

async function main() {
    const project = new Project({
        tsConfigFilePath: "tsconfig.json",
    });

    const outputDir = path.join(__dirname, 'src', 'generated');
    fs.rmSync(outputDir, { recursive: true, force: true }); // Clean previous generations
    fs.mkdirSync(outputDir, { recursive: true });

    const allSourceFiles = project.getSourceFiles("src/**/*.ts");
    const generatedServices: GeneratedService[] = [];

    console.log("Scanning for @AutoGen decorators...");

    for (const sourceFile of allSourceFiles) {
        const classes = sourceFile.getClasses();
        for (const cls of classes) {
            const properties = cls.getProperties();
            for (const prop of properties) {
                const decorator = prop.getDecorator("AutoGen");
                if (!decorator) continue;

                console.log(`Found @AutoGen on ${cls.getName()}.${prop.getName()}`);

                const propType = prop.getType();
                const targetType = propType.isUnion() ? propType.getUnionTypes().find(t => !t.isUndefined()) : propType;

                if (!targetType) {
                    console.error(`  -> Error: Could not resolve type for ${prop.getName()}`);
                    continue;
                }

                const typeSymbol = targetType.getSymbol();
                if (!typeSymbol) {
                    console.error(`  -> Error: Could not find symbol for type ${targetType.getText()}`);
                    continue;
                }

                const decl = typeSymbol.getDeclarations()[0];
                if (!decl || !decl.isKind(ts.SyntaxKind.InterfaceDeclaration)) {
                    console.error(`  -> Error: Type ${targetType.getText()} is not a resolvable interface.`);
                    continue;
                }

                const interfaceDecl = decl as InterfaceDeclaration;
                const interfaceName = interfaceDecl.getName();
                const implName = `${interfaceName}Impl`;
                const implFileName = `${interfaceName.toLowerCase()}.service.impl.ts`;
                const implFilePath = path.join(outputDir, implFileName);

                console.log(`  -> Generating implementation for ${interfaceName}...`);
                const generatedCode = await callOllama(interfaceDecl, path.relative(outputDir, sourceFile.getFilePath()).replace(/\\/g, '/').replace(/\.ts$/, ''));
                fs.writeFileSync(implFilePath, generatedCode);
                console.log(`  -> Wrote to ${implFilePath}`);

                generatedServices.push({
                    interfaceName,
                    implName,
                    implFilePath: `./${implFileName}`,
                });
            }
        }
    }

    if (generatedServices.length > 0) {
        console.log("\nGenerating DI container...");
        await generateContainer(outputDir, generatedServices);
        console.log("DI container generated successfully.");
    } else {
        console.log("No @AutoGen decorators found. Nothing to generate.");
    }
}

/**
 * Mocks a call to an LLM to generate a class implementation from an interface.
 * @param interfaceDeclaration The interface to implement.
 * @returns A string containing the generated class code.
 */
async function callLLM_mock(interfaceDeclaration: InterfaceDeclaration, originalImportPath: string): Promise<string> {
    const interfaceName = interfaceDeclaration.getName();
    const implName = `${interfaceName}Impl`;

    // This is a simplified mock. A real implementation would involve a complex prompt.
    const generatedMethods = interfaceDeclaration.getMethods().map(method => {
        const methodName = method.getName();
        const params = method.getParameters().map(p => `${p.getName()}: ${p.getType().getText()}`).join(', ');
        const returnType = method.getReturnType().getText();

        return `    ${methodName}(${params}): ${returnType} {
        // TODO: Implement mock logic for ${methodName}
        console.log('Calling method: ${methodName}');
    }`;
    });

    return `// Generated by AutoGen at ${new Date().toISOString()}
import { ${interfaceName} } from '${originalImportPath}';

export class ${implName} implements ${interfaceName} {
${generatedMethods.join('\n\n')}
}
`;
}

/**
 * Calls a local Ollama instance to generate a class implementation from an interface.
 * @param interfaceDeclaration The interface to implement.
 * @param originalImportPath The relative path to the original interface file.
 * @returns A string containing the generated class code.
 */
async function callOllama(interfaceDeclaration: InterfaceDeclaration, originalImportPath: string): Promise<string> {
    const interfaceName = interfaceDeclaration.getName();
    const interfaceCode = interfaceDeclaration.getFullText();

    // --- AST Analysis to find dependent types ---
    const dependentTypesCode = new Map<string, { code: string, path: string }>();

    const typesToProcess = [...interfaceDeclaration.getMethods().flatMap(m => [...m.getParameters().map(p => p.getType()), m.getReturnType()])];

    for (const type of typesToProcess) {
        const symbol = type.getAliasSymbol() ?? type.getSymbol();
        if (!symbol) continue;

        for (const declaration of symbol.getDeclarations()) {
            const sourceFile = declaration.getSourceFile();
            const declarationFilePath = sourceFile.getFilePath();

            // Skip primitive types and types from node_modules
            if (sourceFile.isFromExternalLibrary() || sourceFile.isDeclarationFile()) {
                continue;
            }

            // Skip the interface being implemented itself
            if (declaration === interfaceDeclaration) {
                continue;
            }

            const typeName = symbol.getName();
            // Skip primitive types and Promise/void
            if (['Promise', 'void', 'string', 'number', 'boolean', 'any', 'unknown', 'never'].includes(typeName)) {
                continue;
            }

            // If the type is in the same file, we don't need a separate import path for it.
            const isSameFile = declarationFilePath === interfaceDeclaration.getSourceFile().getFilePath();

            if (!dependentTypesCode.has(typeName)) {
                const importPath = path.relative(path.dirname(interfaceDeclaration.getSourceFile().getFilePath()), declarationFilePath).replace(/\.ts$/, '');
                dependentTypesCode.set(typeName, { code: declaration.getFullText(), path: importPath });
            }
        }
    }

    let dependentCodeBlock = '';
    if (dependentTypesCode.size > 0) {
        dependentCodeBlock += 'Here are the definitions of the types it depends on:\n\n';
        for (const [typeName, { code, path: importPath }] of dependentTypesCode.entries()) {
            dependentCodeBlock += `From '${importPath}':\n`;
            dependentCodeBlock += `\`\`\`typescript\n${code}\n\`\`\`\n\n`;
        }
    }

    // Construct the prompt for the LLM
    const prompt = `
You are an expert TypeScript developer. Your task is to generate a concrete implementation for the following TypeScript interface.
The implementation should be a class named '${interfaceName}Impl'.
The generated class must implement the interface '${interfaceName}' and be exported.
Provide only the TypeScript code for the class implementation, without any additional explanations, comments, or markdown formatting.
The generated code should start with a comment like '// Generated by AutoGen...' and include the necessary imports.

The original interface is defined in '${originalImportPath}'.

${dependentCodeBlock}Here is the interface code:
\`\`\`typescript
${interfaceCode}
\`\`\`

CRITICAL: You must respond with only the raw TypeScript code for the implementation file. The response should contain nothing else.
`;

    console.log(`  -> Sending prompt to Ollama for ${interfaceName}...`);
    console.log(`  -> prompt: ${prompt}`);
    try {
        const response = await fetch('http://localhost:11434/api/generate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                model: "codellama", // IMPORTANT: Change this to your desired Ollama model
                prompt: prompt,
                stream: false,
            }),
        });

        if (!response.ok) {
            const errorBody = await response.text();
            throw new Error(`Ollama API request failed with status ${response.status}: ${errorBody}`);
        }

        const result = await response.json();

        // Clean up the response from the LLM, removing markdown fences
        const rawCode = result.response || '';
        const cleanedCode = rawCode.replace(/```typescript/g, '').replace(/```/g, '').trim();

        console.log(`  -> result: ${cleanedCode}`);

        return cleanedCode;

    } catch (error) {
        console.error("  -> Error calling Ollama:", error);
        // Fallback to a mock implementation in case of error
        console.error("  -> Falling back to mock implementation.");
        return `// Generated by AutoGen (fallback) at ${new Date().toISOString()}
import { ${interfaceName} } from '${originalImportPath}';

// ERROR: Could not generate implementation from Ollama.
export class ${interfaceName}Impl implements ${interfaceName} {
    // TODO: Implement methods manually.
}
`;
    }
}

async function generateContainer(outputDir: string, services: GeneratedService[]) {
    const imports = services.map(s => `import { ${s.implName} } from '${s.implFilePath.replace(/\\/g, '/').replace(/\.ts$/, '')}';`).join('\n');

    const cases = services.map(s => `        case '${s.interfaceName}':\n            return new ${s.implName}();`).join('\n');

    const typeMappings = services.map(s => `    '${s.interfaceName}': ${s.implName};`).join('\n');

    const containerCode = `// Generated by AutoGen at ${new Date().toISOString()}
${imports}

// A simple map of interface names to implementation classes
interface ServiceMap {
${typeMappings}
}

class Container {
    private instances: Map<keyof ServiceMap, any> = new Map();

    public get<K extends keyof ServiceMap>(identifier: K): ServiceMap[K] {
        if (!this.instances.has(identifier)) {
            const instance = this.createInstance(identifier);
            this.instances.set(identifier, instance);
        }
        return this.instances.get(identifier)!;
    }

    private createInstance<K extends keyof ServiceMap>(identifier: K): ServiceMap[K] {
        switch (identifier) {
${cases}
        default:
            throw new Error('Service not found for identifier: ' + identifier);
        }
    }
}

export const container = new Container();
`;

    const outputPath = path.join(outputDir, 'container.ts');
    fs.writeFileSync(outputPath, containerCode);
}

main().catch(err => {
    console.error("An unexpected error occurred:", err);
});