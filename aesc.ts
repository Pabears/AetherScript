import { Project, InterfaceDeclaration, ts } from "ts-morph";
import * as fs from 'fs';
import * as path from 'path';

type GeneratedService = {
    interfaceName: string;
    implName: string;
    implFilePath: string;
};

async function main() {
    const project = new Project({
        tsConfigFilePath: "tsconfig.json",
    });

    const outputDir = path.join(__dirname, 'src', 'generated');
    fs.rmSync(outputDir, { recursive: true, force: true }); // Clean previous generations
    fs.mkdirSync(outputDir, { recursive: true });

    const allSourceFiles = project.getSourceFiles("src/**/*.ts");
    const generatedServices: GeneratedService[] = [];

    console.log("Scanning for @AutoGen decorators...");

    for (const sourceFile of allSourceFiles) {
        const classes = sourceFile.getClasses();
        for (const cls of classes) {
            const properties = cls.getProperties();
            for (const prop of properties) {
                const decorator = prop.getDecorator("AutoGen");
                if (!decorator) continue;

                console.log(`Found @AutoGen on ${cls.getName()}.${prop.getName()}`);

                const propType = prop.getType();
                const targetType = propType.isUnion() ? propType.getUnionTypes().find(t => !t.isUndefined()) : propType;

                if (!targetType) {
                    console.error(`  -> Error: Could not resolve type for ${prop.getName()}`);
                    continue;
                }

                const typeSymbol = targetType.getSymbol();
                if (!typeSymbol) {
                    console.error(`  -> Error: Could not find symbol for type ${targetType.getText()}`);
                    continue;
                }

                const decl = typeSymbol.getDeclarations()[0];
                if (!decl || !decl.isKind(ts.SyntaxKind.InterfaceDeclaration)) {
                    console.error(`  -> Error: Type ${targetType.getText()} is not a resolvable interface.`);
                    continue;
                }

                const interfaceDecl = decl as InterfaceDeclaration;
                const interfaceName = interfaceDecl.getName();
                const implName = `${interfaceName}Impl`;
                const implFileName = `${interfaceName.toLowerCase()}.service.impl.ts`;
                const implFilePath = path.join(outputDir, implFileName);

                console.log(`  -> Generating implementation for ${interfaceName}...`);
                const generatedCode = await callLLM_mock(interfaceDecl, path.relative(outputDir, sourceFile.getFilePath()).replace(/\\/g, '/').replace(/\.ts$/, ''));
                fs.writeFileSync(implFilePath, generatedCode);
                console.log(`  -> Wrote to ${implFilePath}`);

                generatedServices.push({
                    interfaceName,
                    implName,
                    implFilePath: `./${implFileName}`,
                });
            }
        }
    }

    if (generatedServices.length > 0) {
        console.log("\nGenerating DI container...");
        await generateContainer(outputDir, generatedServices);
        console.log("DI container generated successfully.");
    } else {
        console.log("No @AutoGen decorators found. Nothing to generate.");
    }
}

/**
 * Mocks a call to an LLM to generate a class implementation from an interface.
 * @param interfaceDeclaration The interface to implement.
 * @returns A string containing the generated class code.
 */
async function callLLM_mock(interfaceDeclaration: InterfaceDeclaration, originalImportPath: string): Promise<string> {
    const interfaceName = interfaceDeclaration.getName();
    const implName = `${interfaceName}Impl`;

    // This is a simplified mock. A real implementation would involve a complex prompt.
    const generatedMethods = interfaceDeclaration.getMethods().map(method => {
        const methodName = method.getName();
        const params = method.getParameters().map(p => `${p.getName()}: ${p.getType().getText()}`).join(', ');
        const returnType = method.getReturnType().getText();
        
        return `    ${methodName}(${params}): ${returnType} {
        // TODO: Implement mock logic for ${methodName}
        console.log('Calling method: ${methodName}');
    }`;
    });

    return `// Generated by AutoGen at ${new Date().toISOString()}
import { ${interfaceName} } from '${originalImportPath}';

export class ${implName} implements ${interfaceName} {
${generatedMethods.join('\n\n')}
}
`;
}

async function generateContainer(outputDir: string, services: GeneratedService[]) {
    const imports = services.map(s => `import { ${s.implName} } from '${s.implFilePath.replace(/\\/g, '/').replace(/\.ts$/, '')}';`).join('\n');

    const cases = services.map(s => `        case '${s.interfaceName}':\n            return new ${s.implName}();`).join('\n');

    const typeMappings = services.map(s => `    '${s.interfaceName}': ${s.implName};`).join('\n');

    const containerCode = `// Generated by AutoGen at ${new Date().toISOString()}
${imports}

// A simple map of interface names to implementation classes
interface ServiceMap {
${typeMappings}
}

class Container {
    private instances: Map<keyof ServiceMap, any> = new Map();

    public get<K extends keyof ServiceMap>(identifier: K): ServiceMap[K] {
        if (!this.instances.has(identifier)) {
            const instance = this.createInstance(identifier);
            this.instances.set(identifier, instance);
        }
        return this.instances.get(identifier)!;
    }

    private createInstance<K extends keyof ServiceMap>(identifier: K): ServiceMap[K] {
        switch (identifier) {
${cases}
        default:
            throw new Error('Service not found for identifier: ' + identifier);
        }
    }
}

export const container = new Container();
`;

    const outputPath = path.join(outputDir, 'container.ts');
    fs.writeFileSync(outputPath, containerCode);
}

main().catch(err => {
    console.error("An unexpected error occurred:", err);
});